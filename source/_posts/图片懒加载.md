---
title: 图片懒加载
date: 2019-02-14 19:22:21
categories: web
tags: ["图片懒加载","函数节流3种方式"]
copyright:
keywords:
description:
---
{% cq %} LazyLoad {% endcq %}
<img src="/img/lazyload.gif">
<!--more-->
# 懒加载的意义
这里‘懒’的意思可以理解为延迟，如淘宝、京东这些电商平台有大量的图片，如果上来就加载服务器表示压力山大，所以就想出了懒加载这种克敌之法，用户滚动到的区域才发送请求加载内容
# 原理
将页面中的img标签src指向一张小照片或者为空都可以，然后写一个自定义属性比如（data-src）指向正确的图片，其实就是用正确的照片替换src里面的照片
# 代码
在写代码前，需要了解各种高度。先看这篇文章[js坐标位置](https://zhanghuaxiao.github.io/2019/02/14/js获取事件坐标位置/)
```javascript
    <head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        img {
            display: block;
            margin-bottom: 50px;
            width: 400px;
            height: 400px;
        }
    </style>
</head>
<body>
    <img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt="">
        <img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt="">
        <img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/3c6d55fbb2fb43161361e1432ba4462309f7d389.jpg" alt="">
        <img src="" data-src="http://pic.58pic.com/58pic/15/68/59/71X58PICNjx_1024.jpg" alt="">
        <img src="" data-src="http://qimg.hxnews.com/2019/0128/1548663985785.jpg" alt="">
        <img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/242dd42a2834349bf8d014a3c3ea15ce37d3bec6.jpg" alt="">
        <img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/d439b6003af33a87089f4704cc5c10385343b53a.jpg" alt="">
        <img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/38dbb6fd5266d01607666e0b9d2bd40735fa3591.jpg" alt="">
        <img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/d043ad4bd11373f02f236d8cae0f4bfbfbed0480.jpg" alt="">
</body>
```
## javascript
```javascript
    var num = document.getElementsByTagName('img').length;
    var img = document.getElementsByTagName("img");
    var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历
    lazyload(); //页面载入完毕加载可是区域内的图片
    window.onscroll = lazyload;
    function lazyload() { //监听页面滚动事件
        var seeHeight = document.documentElement.clientHeight; //可见区域高度
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度
        for (var i = n; i < num; i++) {
            if (img[i].offsetTop < seeHeight + scrollTop) {
                if (img[i].getAttribute("src") == "") {
                    img[i].src = img[i].getAttribute("data-src");
                }
                n = i + 1;
            }
        }
    }
```
## 使用节流函数进行性能优化
如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。
我想实现限制触发频率，来优化性能。

节流函数：只允许一个函数在N秒内执行一次。下面是一个通俗易通的节流函数：
{%codeblock lang:javascript%}
    var num = document.getElementsByTagName('img').length;
    var img = document.getElementsByTagName("img");
    var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历
    resizehandler(); //页面载入完毕加载可是区域内的图片
    n=0;
    function resizehandler(){
        var seeHeight = document.documentElement.clientHeight; //可见区域高度
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度
        for (var i = n; i < num; i++) {
            if (img[i].offsetTop < seeHeight + scrollTop) {
                if (img[i].getAttribute("src") == "") {
                    img[i].src = img[i].getAttribute("data-src");
                }
                n = i + 1;
            }
        }
    }
    function throttle(method,context){
        clearTimeout(method.tId);
        method.tId=setTimeout(function(){
            method.call(context);
        },500);
    }
    window.onscroll=function(){
        throttle(resizehandler,window);
    }
{% endcodeblock %}    
# 函数节流方案以下三种
## 时间戳方案
{% codeblock lang:javascript%}
    var num = document.getElementsByTagName('img').length;
    var img = document.getElementsByTagName("img");
    var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历
    lazyload(); //页面载入完毕加载可是区域内的图片
    function lazyload() { //监听页面滚动事件
        var seeHeight = document.documentElement.clientHeight; //可见区域高度
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度
        for (var i = n; i < num; i++) {
            if (img[i].offsetTop < seeHeight + scrollTop) {
                if (img[i].getAttribute("src") == "") {
                    img[i].src = img[i].getAttribute("data-src");
                }
                n = i + 1;
            }
        }
    }
---------------------------------  以上代码不在重复  --------------------------------
    var throttle = function(fun,delay){
        var perv = Date.now();
        return function(){
            var context = this;
            var now = Date.now();
            if (now-perv >= delay){
                fun.apply(context,arguments)
                prev = Date.now();
            }
        }
    }
    window.addEventListener('scroll',throttle(lazyload,1000))
{% endcodeblock %}
## 定时器方案
{% codeblock lang:javascript %}
    var throttle = function(fun,delay){
        var timer = null;
        return function(){
            var context = this;
            if(!timer){
                timer = setTimeout(function(){
                    fun.apply(context,arguments)
                    timer = null
                },delay)
            }
        }
    }
    window.addEventListener('scroll',throttle(lazyload,1000))
{% endcodeblock %}
## 时间戳+定时器方案
{% codeblock lang:javascript %}
    var throttle = function(fun,delay){
        var timer = null;
        var startTime = Date.now();
        return function() {
                var curTime = Date.now();
                var remaining = delay - (curTime - startTime);
                var context = this;
                var args = arguments;
                clearTimeout(timer);
                if (remaining <= 0) {
                        fun.apply(context, args);
                        startTime = Date.now();
                } else {
                        timer = setTimeout(fun, remaining);
                }
        }
    }
    window.addEventListener('scroll',throttle(lazyload,1000))
{% endcodeblock %}